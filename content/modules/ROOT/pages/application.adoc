= Develop Automotive Software In Dev Space
:sectnums:

In this module we will learn how to develop, build and test a simple automotive application in Red Hat OpenShift Dev Spaces.

The source repo contains a set of applications that demonstrate how typical automotive applications use SOME/IP to talk to each other, these apps work both natively and in a container. For the purpose of this lab, we would be focusing on `radio-service`, This is a service that emulates a radio, regularly publishing information about the current song, radio station and volume. It accepts requests to turn on/off, switch channel, and change volume.

== Build, Test And Publish A Simple Automotive Application

The process of building, testing and publishing our simple automative application would happen in the terminal of our Dev Space.

image::18-vscode.png[]

IMPORTANT: placeholder image

Press `Ctrl+`` to open the terminal.

image::18-vscode.png[]

IMPORTANT: placeholder image

=== Build

In the terminal, run the following commands:

[,console]
----
$ cmake .
$ make
----

TIP: `cmake .` generates `Makefile` from `CMakeLists.txt` in our current working directory (`.`), which contains high-level instructions on how to build the applications. While `make` executes the generated low-level instructions in `Makefile` to actually build the applications.

Check the content of our working directory by running the following command.

[,console]
----
$ ls
----

You should see a few executable files we've just built, including `radio-service` and `radio-client`.

=== Test

To test our `radio-service` application, we need to first start in in the backgroud:

[,console]
----
$ ./radio-service &
----

TIP: `&` at the end of the command means executing it in the background, which frees up the terminal for us to run other commands in parallel.

You will see the `radio-service` periodically print its current status into the terminal, in lines like `RADIO: Playing song "Upper Echelon" by Travi$ Scott feat. 2 Chainz & T.I. (on Radio Los Santos) 50% volume`

Then we can start `radio-client` in the foreground to interact with `radio-service`.

[,console]
----
$ ./radio-client
----

Press `+` or `-` to adjust the volume, `<SPACE>` to switch station, `<ESC>` to pause or resume the radio, and notice changes in the printed status messages in response to your requests.

When done with testing, press `q` to quit the client, and stop `radio-service` by running:

[,console]
----
$ pkill radio-service
----

=== Modify (Optional)

If you are confident with programing in the C++ language, feel free to make modification to `radio-stations.cpp` adding songs or stations, and repeat the build test cycle.

.Example
[%collapsible]
====
[source,diff]
----
diff --git a/radio-stations.cpp b/radio-stations.cpp
index 079a5ee..dc1abd3 100644
--- a/radio-stations.cpp
+++ b/radio-stations.cpp
@@ -2,6 +2,10 @@
 
 #define SONGS(_station) (_station ## _songs), sizeof(_station ## _songs)/sizeof(struct song_info_t)
 
+static struct song_info_t wgbh_songs[] = {
+ { "Nestor Torres", "Thank You Willie", 2022 },
+};
+
 static struct song_info_t radio_los_santos_songs[] = {
   { "YG", "I'm A Real 1", 2013 },
   { "100s", "Life of a Mack", 2013 },
@@ -468,6 +472,7 @@ static struct song_info_t the_lab_songs[] = {
 };
 
 static struct radio_station_info_t radio_stations[] = {
+  { "WGBH", SONGS(wgbh) },
   { "Radio Los Santos", SONGS(radio_los_santos) },
   { "Space 103.2", SONGS(space_103_2) },
   { "West Coast Classics", SONGS(west_cost_classics) },
----
====

=== Publish

Now we've finished developing and testing our application, we can publish it to our code repository.

[,console]
----
$ git commit -a -m "first revision" --allow-empty
$ git tag v0.0.1
$ git push
$ git push --tags
----

Once the changes are pushed to the code repository, an *Red Hat OpenShift Pipelines* task is triggered to automatically build the application and bundle it into a container.

TIP: Container is a format for packaging an application and all its dependencies into a single unit, to ease the distribution of applications.

To check the progress of the build, see  {app_build_pipeline}

== Next Steps

While *Red Hat OpenShift Dev Spaces* provides us with a convenient environment for developing, building and testing our automotive applications, we still need to test our application in an environment closer to the real-world deployments to ensure its functionality and stability in the field. In the next module we will build an *RHIVOS* image with our application embedded, to prepare for end-to-end testing in both virtualized and real hardware environments with *Jumpstarter*.

== Build RHIVOS Image

=== Automotive Image Builder

To build RHIVOS images, we would be using https://gitlab.com/CentOS/automotive/src/automotive-image-builder[automotive image builder], a tool to create various kinds of OS images based on CentOS derived distributions. The main tool is called `automotive-image-builder`, and the basic operation it does is called "composing" manifests. The compose operation takes a yaml-based automotive image manifest, as well as a set of options affecting the compose and resolves the manifest into an osbuild json file. This json file is a precise build instruction for how to build an image with osbuild with the very specific software that was chosen during the compose. For example, the version of selected packages and container images is chosen during the compose.

=== Automotive Image Builder Manifests

The source repo is already populated with some automotive image builder manifests for RHIVOS. From the file explorer of the Dev Space, open `manifests/simple.aib.yml`, which is an example showing how to build a minimal RHIVOS image with additional rpm packages and root password preset. Another noteworthy file is `.aib-ci.yml`, which specifies the base image to use, target architecture and board, and other parameters to be passed to `automotive-image-builder`

=== Build RHIVOS image with Automotive Image Builder

Automotive image builder does not support cross-compilation, to build images for other architectures (like aarch64), we must run it on the respective systems. A aarch64 base virtual machine is provisioned as part of the lab to serve as our builder host. A helper script is provided to execute the build on it, in the Dev Space terminal, run:

[source,bash]
----
aib-build qemu simple.qcow2
----

NOTE: We are using the `qemu` preset in `.aib-ci.yaml` to build an image targeting the qemu platform, and store the resulting image as `simple.qcow2`

A GitLab CI task was also triggered to build the RHIVOS image with the application container embeded. You can check the build process here:

{os_build_pipeline}
