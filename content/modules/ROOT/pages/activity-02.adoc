= Build the Sample Application
:sectnums:

In this module we will learn how to develop, build, and test a simple automotive application using Red Hat OpenShift Dev Spaces.

The source repo contains a set of applications that demonstrate how typical automotive applications use SOME/IP communicate, these apps work both natively and in a container. For the purpose of this lab, we would be focusing on the `radio-service` application. This is a service that emulates a radio, regularly publishing information about the current track, station, and volume level. This service accepts requests to turn on/off, change channel, and adjust the volume over SOME/IP.

== Build, Test, and Publish a Simple Automotive Application

We can easily build, test, and publish our application using the cmake build system in our Dev Space.

=== Build the Applications

image::app/00-build.png[]

Click *build* button at the bottom left of the window.

'''

image::app/01-kit.png[]

Choose to build with the GCC toolkit.

.The build process
****
The demo application is built using the *cmake* build system. The build process involves creating a "build" directory, and calling cmake to generate the Makefile,
then make will be called to compile the source code into multiple executable files. The cmake vscode plugin automatically detects the source code and
performs those steps on your behalf, but you can also do it manually if you want to.
****


=== Test the Applications

image::app/02-build-finish.png[]

After finishing building (the line *Build finished with exit code 0* shows up in the *OUTPUT*), click the triangular button at the bottom left of the window to run our application.

'''

image::app/03-run.png[]

Choose to run *radio-service*.

'''

When the radio service is running, you will see log lines like

[,console]
----
RADIO: Playing song "Upper Echelon" by Travi$ Scott feat. 2 Chainz & T.I. (on Radio Los Santos) 50% volume
----

image::app/04-running.png[]

showing up in the terminal. Next, we can start the `radio-client` to interact the running `radio-service`. First, split the terminal by clicking book like button on the right middle of the screen.

'''

image::app/05-split.png[]

You will see the terminal being split into two halves, with the radio service running on the left, and bash shell on the right.

'''

image::app/06-run-client.png[]

Start *radio-client* by clicking the right half of the terminal, type `./radio-client` then press `Enter`.

'''

image::app/07-client-running.png[]

In the radio client, press `+` or `-` to adjust the volume, `<SPACE>` to switch stations, and `<ESC>` to pause or resume the radio. Notice the changes in the printed status messages in response to your requests.

When done with testing, press `q` to quit the client.

=== Modify the Radio Service (Optional)

If you are confident with programing in C++, feel free to make some changes to the `radio-stations.cpp` source file. You can add songs or stations, and repeat the build test cycle.

.Example
[%collapsible]
====
image::app/08-src.png[]

Click `src` in the file explorer to open the src folder.

'''

image::app/09-stations.png[]

Click `radio-stations.cpp` to open the source file containing the radio stations and songs.

'''

image::app/10-songs-before.png[]

At the top of the file, remove the two annotated lines.

'''

image::app/11-songs-after.png[]

The remaining lines should look like this after editing.

'''

image::app/12-stations-before.png[]

Scroll down to the bottom of the file, remote the two annotated lines.

'''

image::app/13-stations-after.png[]

The remaining lines should look like this after editing.

'''

After finishing editing, click the triangular button at the bottom left of the window to rerun `radio-service`, and start `radio-client` again on the right half of the terminal. Try switching stations by pressing `<SPACE>`, and find the newly added *Red Hat Summit Radio* station.
====

=== Publish Applications

Now that we've finished developing and testing our code, we can publish it to our code repository.

image::app/14-branch.png[]

Bring up the branch selector by clicking the button saying `main` at the bottom left of the screen.

'''

image::app/15-branch-create.png[]

In the input box, put `develop`, then click *Create new branch*.

'''

image::app/16-branch-created.png[]

Make sure the button on the bottom left of the screen now says `develop`, the name of the newly created branch, click the annotated button on the left to open the source control tab.

'''

image::app/17-commit.png[]

In the input box, put `add new radio station` as the commit message, click *Commit*.

'''

image::app/18-push.png[]

Click the cloud like button to push the new changes to our code repository.

'''

Once the changes are pushed to the code repository, a *Red Hat OpenShift Pipelines* task is triggered to automatically build the application and bundle it into a container.

TIP: We're using a container as it's the best way to package an application and all of its dependencies into a single unit. This makes it simple to distribute to physical or virtual  hardware for testing.

To check the progress of the build, see {app_build_pipeline}

== Next Steps

While *Red Hat OpenShift Dev Spaces* provides us with a consistent environment for developing, building, and testing our automotive applications, it's still necessary to test our code on virtual or physical hardware to ensure stability and compatibility.

In the next module we will build a *RHIVOS* image with our application embedded to prepare for end-to-end testing in both virtualized and physical hardware environments with *Jumpstarter*.
